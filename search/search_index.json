{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the BuildDSL documentation! A superset of the Python programming language with support for closures and multi-line lambdas. BuildDSL is an \"almost superset\" of Python 3; adding a lot of syntactical features that make it more convenient to describe build configurations at the cost of some other syntax features of the native Python language (like set literals). Installation $ pip install builddsl The builddsl package requires at least Python 3.8. Projects using BuildDSL Novella","title":"Home"},{"location":"#welcome-to-the-builddsl-documentation","text":"A superset of the Python programming language with support for closures and multi-line lambdas. BuildDSL is an \"almost superset\" of Python 3; adding a lot of syntactical features that make it more convenient to describe build configurations at the cost of some other syntax features of the native Python language (like set literals).","title":"Welcome to the BuildDSL documentation!"},{"location":"#installation","text":"$ pip install builddsl The builddsl package requires at least Python 3.8.","title":"Installation"},{"location":"#projects-using-builddsl","text":"Novella","title":"Projects using BuildDSL"},{"location":"changelog/","text":"Changelog Unreleased Type Description PR Issues Author Feature add `UnboundClosure` intermediate type @NiklasRosenstein 0.9.0 (2022-04-21) Type Description PR Issues Author Feature Expose `NameRewriter` functionality as a a public API under the name `builddsl.ast_utils.DynamicLookupRewriter` @NiklasRosenstein 0.8.5 (2022-04-19) Type Description PR Issues Author Improvement Add `Context.chain_with()` @NiklasRosenstein Improvement Add `Closure(target_context)` parameter @NiklasRosenstein 0.8.4 (2022-04-19) Type Description PR Issues Author Fix Support previously missing `!=` comparator @NiklasRosenstein 0.8.3 (2022-04-19) Type Description PR Issues Author Fix Fix `import module` not treating `module` as a local variable definition 8 @NiklasRosenstein 0.8.2 (2022-04-18) Type Description PR Issues Author Improvement Disable debug line that is really just useful for debugging in the project directly; @NiklasRosenstein 0.8.1 (2022-04-14) Type Description PR Issues Author Improvement Make `astor` dependency an extra called \"astor\", it is required only for `transpile_to_source()` @NiklasRosenstein 0.8.0 (2022-04-13) Type Description PR Issues Author Feature support Python 3.7 @NiklasRosenstein 0.7.7 (2022-02-27) Type Description PR Issues Author Improvement support Python 3.8+ (before was 3.10) @NiklasRosenstein 0.7.6 (2022-02-27) Type Description PR Issues Author Fix support walrus operator (`:=`) 5 @NiklasRosenstein 0.7.5 (2022-02-27) Type Description PR Issues Author Fix support more assignment operators like `+=`, `-=`, etc. as well as `and` and `or` binary operators 7 @NiklasRosenstein","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#unreleased","text":"Type Description PR Issues Author Feature add `UnboundClosure` intermediate type @NiklasRosenstein","title":"Unreleased"},{"location":"changelog/#090-2022-04-21","text":"Type Description PR Issues Author Feature Expose `NameRewriter` functionality as a a public API under the name `builddsl.ast_utils.DynamicLookupRewriter` @NiklasRosenstein","title":"0.9.0 (2022-04-21)"},{"location":"changelog/#085-2022-04-19","text":"Type Description PR Issues Author Improvement Add `Context.chain_with()` @NiklasRosenstein Improvement Add `Closure(target_context)` parameter @NiklasRosenstein","title":"0.8.5 (2022-04-19)"},{"location":"changelog/#084-2022-04-19","text":"Type Description PR Issues Author Fix Support previously missing `!=` comparator @NiklasRosenstein","title":"0.8.4 (2022-04-19)"},{"location":"changelog/#083-2022-04-19","text":"Type Description PR Issues Author Fix Fix `import module` not treating `module` as a local variable definition 8 @NiklasRosenstein","title":"0.8.3 (2022-04-19)"},{"location":"changelog/#082-2022-04-18","text":"Type Description PR Issues Author Improvement Disable debug line that is really just useful for debugging in the project directly; @NiklasRosenstein","title":"0.8.2 (2022-04-18)"},{"location":"changelog/#081-2022-04-14","text":"Type Description PR Issues Author Improvement Make `astor` dependency an extra called \"astor\", it is required only for `transpile_to_source()` @NiklasRosenstein","title":"0.8.1 (2022-04-14)"},{"location":"changelog/#080-2022-04-13","text":"Type Description PR Issues Author Feature support Python 3.7 @NiklasRosenstein","title":"0.8.0 (2022-04-13)"},{"location":"changelog/#077-2022-02-27","text":"Type Description PR Issues Author Improvement support Python 3.8+ (before was 3.10) @NiklasRosenstein","title":"0.7.7 (2022-02-27)"},{"location":"changelog/#076-2022-02-27","text":"Type Description PR Issues Author Fix support walrus operator (`:=`) 5 @NiklasRosenstein","title":"0.7.6 (2022-02-27)"},{"location":"changelog/#075-2022-02-27","text":"Type Description PR Issues Author Fix support more assignment operators like `+=`, `-=`, etc. as well as `and` and `or` binary operators 7 @NiklasRosenstein","title":"0.7.5 (2022-02-27)"},{"location":"introduction/","text":"Introduction BuildDSL is a Python superset language inspired by Gradle. It introduces additional syntactic constructs into the language, such as paren-less function calls, colon keyword arguments, paren-less line-spanning statements without newline escaping and multi-line lambdas (called \"closures\"). Optionally, a feature can be enabled to allow for dynamic variable name resolution which allows for a concise syntax that does not require prefixing members of the closure target with self . Example This might be a bit of a convoluted way to print \"Hello, World\", but it shows well how closures in BuildDSL work: # hello.build world = { self ( 'World!' ) } world { print ( 'Hello,' , self ) } This transpiles to Standard Dynamic name resolution # $ python -m builddsl hello.build -E | grep -v -e '^$' def _closure_1 ( self , * arguments , ** kwarguments ): self ( 'World!' ) world = _closure_1 def _closure_2 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) world ( _closure_2 ) # $ python -m builddsl hello.build -E -C | grep -v -e '^$' @__closure__ . subclosure def _closure_1 ( __closure__ , self , * arguments , ** kwarguments ): self ( 'World!' ) __closure__ [ 'world' ] = _closure_1 @__closure__ . subclosure def _closure_2 ( __closure__ , self , * arguments , ** kwarguments ): __closure__ [ 'print' ]( 'Hello,' , self ) __closure__ [ 'world' ]( _closure_2 ) And evaluates to # $ python -m builddsl hello.build Hello , World ! Note BuildDSL is not usually designed to be used for standalone scripts, but usually as a configuration language for other systems. It is therefore uncommon to run any production code through python -m builddsl . Code transpiled using dynamic name resolution requires a root closure to be supplied as well, which is not possible via the command-line. However, the command-line interface is very useful to run quick tests and to inspect what the transpiled version of the code looks like.","title":"Introduction"},{"location":"introduction/#introduction","text":"BuildDSL is a Python superset language inspired by Gradle. It introduces additional syntactic constructs into the language, such as paren-less function calls, colon keyword arguments, paren-less line-spanning statements without newline escaping and multi-line lambdas (called \"closures\"). Optionally, a feature can be enabled to allow for dynamic variable name resolution which allows for a concise syntax that does not require prefixing members of the closure target with self .","title":"Introduction"},{"location":"introduction/#example","text":"This might be a bit of a convoluted way to print \"Hello, World\", but it shows well how closures in BuildDSL work: # hello.build world = { self ( 'World!' ) } world { print ( 'Hello,' , self ) } This transpiles to Standard Dynamic name resolution # $ python -m builddsl hello.build -E | grep -v -e '^$' def _closure_1 ( self , * arguments , ** kwarguments ): self ( 'World!' ) world = _closure_1 def _closure_2 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) world ( _closure_2 ) # $ python -m builddsl hello.build -E -C | grep -v -e '^$' @__closure__ . subclosure def _closure_1 ( __closure__ , self , * arguments , ** kwarguments ): self ( 'World!' ) __closure__ [ 'world' ] = _closure_1 @__closure__ . subclosure def _closure_2 ( __closure__ , self , * arguments , ** kwarguments ): __closure__ [ 'print' ]( 'Hello,' , self ) __closure__ [ 'world' ]( _closure_2 ) And evaluates to # $ python -m builddsl hello.build Hello , World ! Note BuildDSL is not usually designed to be used for standalone scripts, but usually as a configuration language for other systems. It is therefore uncommon to run any production code through python -m builddsl . Code transpiled using dynamic name resolution requires a root closure to be supplied as well, which is not possible via the command-line. However, the command-line interface is very useful to run quick tests and to inspect what the transpiled version of the code looks like.","title":"Example"},{"location":"api/cli/","text":"Command-line $ python -m builddsl -h # exited with return code 1 /opt/hostedtoolcache/Python/3.10.8/x64/bin/python: No module named builddsl","title":"Command-line"},{"location":"api/cli/#command-line","text":"$ python -m builddsl -h # exited with return code 1 /opt/hostedtoolcache/Python/3.10.8/x64/bin/python: No module named builddsl","title":"Command-line"},{"location":"api/docs/","text":"Documentation @pydoc builddsl.execute @pydoc builddsl.Grammar @pydoc builddsl.SyntaxError @pydoc builddsl.ChainContext @pydoc builddsl.Closure @pydoc builddsl.Context @pydoc builddsl.MapContext @pydoc builddsl.ObjectContext @pydoc builddsl.TranspileOptions @pydoc builddsl.transpile_to_ast @pydoc builddsl.transpile_to_source","title":"Documentation"},{"location":"api/docs/#documentation","text":"@pydoc builddsl.execute @pydoc builddsl.Grammar @pydoc builddsl.SyntaxError @pydoc builddsl.ChainContext @pydoc builddsl.Closure @pydoc builddsl.Context @pydoc builddsl.MapContext @pydoc builddsl.ObjectContext @pydoc builddsl.TranspileOptions @pydoc builddsl.transpile_to_ast @pydoc builddsl.transpile_to_source","title":"Documentation"},{"location":"api/usage-example/","text":"Usage example This example is from the Novella project. It uses the builddsl.Closure class to execute a file that contains BuildDSL code using a NovellaContext object as the root closure target. This allows members of the target object to be invoked at the top-level of the script directly without explicitly prefixing the member names with self or any of the sort. class Novella : \"\"\" This class is the main entrypoint for starting and controlling a Novella build. \"\"\" BUILD_FILE = Path ( 'build.novella' ) def __init__ ( self , project_directory : Path ) -> None : self . project_directory = project_directory def execute_file ( self , file : Path | None = None ) -> NovellaContext : \"\"\" Execute a file, allowing it to populate the Novella pipeline. \"\"\" from builddsl import Closure context = NovellaContext ( self ) file = file or self . BUILD_FILE Closure ( None , None , context ) . run_code ( file . read_text (), str ( file )) return context class NovellaContext : def do ( self , action_type_name : str , closure : t . Callable | None = None , name : str | None = None , ) -> None : # ... Example script do \"copy-files\" { content = [ \"content\" , \"mkdocs.yml\" ] }","title":"Usage example"},{"location":"api/usage-example/#usage-example","text":"This example is from the Novella project. It uses the builddsl.Closure class to execute a file that contains BuildDSL code using a NovellaContext object as the root closure target. This allows members of the target object to be invoked at the top-level of the script directly without explicitly prefixing the member names with self or any of the sort. class Novella : \"\"\" This class is the main entrypoint for starting and controlling a Novella build. \"\"\" BUILD_FILE = Path ( 'build.novella' ) def __init__ ( self , project_directory : Path ) -> None : self . project_directory = project_directory def execute_file ( self , file : Path | None = None ) -> NovellaContext : \"\"\" Execute a file, allowing it to populate the Novella pipeline. \"\"\" from builddsl import Closure context = NovellaContext ( self ) file = file or self . BUILD_FILE Closure ( None , None , context ) . run_code ( file . read_text (), str ( file )) return context class NovellaContext : def do ( self , action_type_name : str , closure : t . Callable | None = None , name : str | None = None , ) -> None : # ... Example script do \"copy-files\" { content = [ \"content\" , \"mkdocs.yml\" ] }","title":"Usage example"},{"location":"syntax/closures/","text":"Closures Closures are formed with the following syntax: [ arg -> | (arg1, arg2, ...) -> ] { body } . A closure without an argument list automatically has the signature (self, *argnames, **kwargnames) . Example 1 BuildDSL Python filter ({ self % 2 }, range ( 5 )) def _closure_1 ( self , * argnames , ** kwargnames ): self % 2 filter ( _closure_1 , range ( 5 )) Example 2 BuildDSL Python filter ( x -> x % 2 , range ( 5 )) def _closure_1 ( x ): return x % 2 filter ( _closure_1 , range ( 5 )) Example 3 BuildDSL Python reduce (( a , b ) -> { a . append ( b * 2 ) return a }, [ 1 , 2 , 3 ], []) def _closure_1 ( a , b ): a . append ( b * 2 ) return a reduce ( _closure_1 , [ 1 , 2 , 3 ], [])","title":"Closures"},{"location":"syntax/closures/#closures","text":"Closures are formed with the following syntax: [ arg -> | (arg1, arg2, ...) -> ] { body } . A closure without an argument list automatically has the signature (self, *argnames, **kwargnames) .","title":"Closures"},{"location":"syntax/closures/#example-1","text":"BuildDSL Python filter ({ self % 2 }, range ( 5 )) def _closure_1 ( self , * argnames , ** kwargnames ): self % 2 filter ( _closure_1 , range ( 5 ))","title":"Example 1"},{"location":"syntax/closures/#example-2","text":"BuildDSL Python filter ( x -> x % 2 , range ( 5 )) def _closure_1 ( x ): return x % 2 filter ( _closure_1 , range ( 5 ))","title":"Example 2"},{"location":"syntax/closures/#example-3","text":"BuildDSL Python reduce (( a , b ) -> { a . append ( b * 2 ) return a }, [ 1 , 2 , 3 ], []) def _closure_1 ( a , b ): a . append ( b * 2 ) return a reduce ( _closure_1 , [ 1 , 2 , 3 ], [])","title":"Example 3"},{"location":"syntax/function-args/","text":"Unseparated arguments & colon keyword arguments The BuildDSL allows passing arguments to function calls without separation by commas. Keyword arguments may be specified using colons ( : ) instead of equal signs ( = ). Example 1 BuildDSL Python print 'Hello, World!' 42 * 1 + 10 file : sys . stdout print ( 'Hello, World!' , 42 * 1 + 10 , file = sys . stdout ) Example 2 BuildDSL Python task \"hello_world\" do : { print \"Hello, World!\" } def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello, World!' ) task ( 'hello_world' , do = _closure_1 ) Example 3 BuildDSL Python list ( map { print ( 'Hello,' , self ) }, [ 'John' , 'World' ]) def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) list ( map , _closure_1 , [ 'John' , 'World' ]) Note : Pitfall, this actually passes three arguments to list() .","title":"Unseparated arguments & colon keyword arguments"},{"location":"syntax/function-args/#unseparated-arguments-colon-keyword-arguments","text":"The BuildDSL allows passing arguments to function calls without separation by commas. Keyword arguments may be specified using colons ( : ) instead of equal signs ( = ).","title":"Unseparated arguments &amp; colon keyword arguments"},{"location":"syntax/function-args/#example-1","text":"BuildDSL Python print 'Hello, World!' 42 * 1 + 10 file : sys . stdout print ( 'Hello, World!' , 42 * 1 + 10 , file = sys . stdout )","title":"Example 1"},{"location":"syntax/function-args/#example-2","text":"BuildDSL Python task \"hello_world\" do : { print \"Hello, World!\" } def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello, World!' ) task ( 'hello_world' , do = _closure_1 )","title":"Example 2"},{"location":"syntax/function-args/#example-3","text":"BuildDSL Python list ( map { print ( 'Hello,' , self ) }, [ 'John' , 'World' ]) def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) list ( map , _closure_1 , [ 'John' , 'World' ]) Note : Pitfall, this actually passes three arguments to list() .","title":"Example 3"},{"location":"syntax/function-calls/","text":"Function calls without parentheses Such function calls are only supported at the statement level. A function can be called without parentheses by simply omitting them. Variadic and keyword arguments are supported as expected. Applying a closure on an object is basically the same as calling that object with the function, and arguments following the closure are still supported. Example 1 BuildDSL Python print 'Hello, World!' , file = sys . stderr print ( 'Hello, World!' , file = sys . stderr ) Example 2 BuildDSL Python map { print ( 'Hello,' , self ) }, [ 'John' , 'World' ] def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) map ( _closure_1 , [ 'John' , 'World' ])","title":"Function calls without parentheses"},{"location":"syntax/function-calls/#function-calls-without-parentheses","text":"Such function calls are only supported at the statement level. A function can be called without parentheses by simply omitting them. Variadic and keyword arguments are supported as expected. Applying a closure on an object is basically the same as calling that object with the function, and arguments following the closure are still supported.","title":"Function calls without parentheses"},{"location":"syntax/function-calls/#example-1","text":"BuildDSL Python print 'Hello, World!' , file = sys . stderr print ( 'Hello, World!' , file = sys . stderr )","title":"Example 1"},{"location":"syntax/function-calls/#example-2","text":"BuildDSL Python map { print ( 'Hello,' , self ) }, [ 'John' , 'World' ] def _closure_1 ( self , * arguments , ** kwarguments ): print ( 'Hello,' , self ) map ( _closure_1 , [ 'John' , 'World' ])","title":"Example 2"},{"location":"syntax/limitations/","text":"Limitations BuildDSL is intended to behave as a complete syntactic superset of standard Python. However there are currently some limitations, namely: Literal sets cannot be expressed due to the grammar conflict with parameter-less closures Type annotations are not currently supported The walrus operator is not currently supported Function calls without parenthesis do not support passing *args as the first argument as that is interpreted as a multiplication expression.","title":"Limitations"},{"location":"syntax/limitations/#limitations","text":"BuildDSL is intended to behave as a complete syntactic superset of standard Python. However there are currently some limitations, namely: Literal sets cannot be expressed due to the grammar conflict with parameter-less closures Type annotations are not currently supported The walrus operator is not currently supported Function calls without parenthesis do not support passing *args as the first argument as that is interpreted as a multiplication expression.","title":"Limitations"},{"location":"syntax/name-resolution/","text":"Dynamic name resolution (non-default) For some purposes and applications, dynamic name resolution may be desirable, for example when writing self in front of every name to access a property of the closure target object is too cumbersome. For this, the BuildDSL transpiler can generate code that looks up, sets and deletes keys using subscript syntax on a particular variable name. Using the builddsl.runtime package, you can configure the transpiler and runtime to use dynamic name resolution. Example usage: from builddsl.transpiler import transpile_to_ast from builddsl.runtime import Closure class Project : def task ( self , name : str , * , do : callable ): ... code = ... filename = ... # Long form: module = transpile_to_ast ( code , filename , Closure . get_options ()) code = compile ( module , filename , 'exec' ) scope = { '__closure__' : Closure ( None , None , Project ())} exec ( code , scope ) # Shorthand form: Closure ( None , None , Project ()) . run_code ( code , filename ) The Closure.get_options() function returns TranspileOptions that instruct the transpiler to convert name lookups into subscripts on the __closure__ variable, add a @__closure__.subclosure decoration before every closure function definition and to add a __closure__, argument to their arglist. The Closure object passed into the scope on execution deals with the rest. BuildDSL Python task \"foobar\" do : { return n_times } task \"belzebub\" do : { def n_times = 1 return n_times } task \"cheeky\" do : { def n_times = 1 return (() -> n_times )() } @__closure__ . subclosure def _closure_1 ( __closure__ , self , * arguments , ** kwarguments ): return __closure__ [ 'n_times' ] __closure__ [ 'task' ]( 'foobar' , do = _closure_1 ) @__closure__ . subclosure def _closure_2 ( __closure__ , self , * arguments , ** kwarguments ): n_times = 1 return n_times __closure__ [ 'task' ]( 'belzebub' , do = _closure_2 ) @__closure__ . subclosure def _closure_3 ( __closure__ , self , * arguments , ** kwarguments ): n_times = 1 @__closure__ . subclosure def _closure_3_closure_3 ( __closure__ ): return n_times return _closure_3_closure_3 () __closure__ [ 'task' ]( 'cheeky' , do = _closure_3 )","title":"Dynamic name resolution <sup>(non-default)</sup>"},{"location":"syntax/name-resolution/#dynamic-name-resolution-non-default","text":"For some purposes and applications, dynamic name resolution may be desirable, for example when writing self in front of every name to access a property of the closure target object is too cumbersome. For this, the BuildDSL transpiler can generate code that looks up, sets and deletes keys using subscript syntax on a particular variable name. Using the builddsl.runtime package, you can configure the transpiler and runtime to use dynamic name resolution. Example usage: from builddsl.transpiler import transpile_to_ast from builddsl.runtime import Closure class Project : def task ( self , name : str , * , do : callable ): ... code = ... filename = ... # Long form: module = transpile_to_ast ( code , filename , Closure . get_options ()) code = compile ( module , filename , 'exec' ) scope = { '__closure__' : Closure ( None , None , Project ())} exec ( code , scope ) # Shorthand form: Closure ( None , None , Project ()) . run_code ( code , filename ) The Closure.get_options() function returns TranspileOptions that instruct the transpiler to convert name lookups into subscripts on the __closure__ variable, add a @__closure__.subclosure decoration before every closure function definition and to add a __closure__, argument to their arglist. The Closure object passed into the scope on execution deals with the rest. BuildDSL Python task \"foobar\" do : { return n_times } task \"belzebub\" do : { def n_times = 1 return n_times } task \"cheeky\" do : { def n_times = 1 return (() -> n_times )() } @__closure__ . subclosure def _closure_1 ( __closure__ , self , * arguments , ** kwarguments ): return __closure__ [ 'n_times' ] __closure__ [ 'task' ]( 'foobar' , do = _closure_1 ) @__closure__ . subclosure def _closure_2 ( __closure__ , self , * arguments , ** kwarguments ): n_times = 1 return n_times __closure__ [ 'task' ]( 'belzebub' , do = _closure_2 ) @__closure__ . subclosure def _closure_3 ( __closure__ , self , * arguments , ** kwarguments ): n_times = 1 @__closure__ . subclosure def _closure_3_closure_3 ( __closure__ ): return n_times return _closure_3_closure_3 () __closure__ [ 'task' ]( 'cheeky' , do = _closure_3 )","title":"Dynamic name resolution (non-default)"}]}