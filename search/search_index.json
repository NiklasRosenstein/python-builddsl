{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the BuildDSL documentation!","text":"<p>A superset of the Python programming language with support for closures and multi-line lambdas.</p> <p>BuildDSL is an \"almost superset\" of Python 3; adding a lot of syntactical features that make it more convenient to describe build configurations at the cost of some other syntax features of the native Python language (like set literals).</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install builddsl\n</code></pre> <p>The <code>builddsl</code> package requires at least Python 3.8.</p>"},{"location":"#projects-using-builddsl","title":"Projects using BuildDSL","text":"<ul> <li>Novella</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"TypeDescriptionPRIssuesAuthor Improvement  Fix pyproject.toml to support NIXszymon.gula@helsing.ai"},{"location":"changelog/#100-2022-12-13","title":"1.0.0 (2022-12-13)","text":"TypeDescriptionPRIssuesAuthor Feature  add `UnboundClosure` intermediate type@NiklasRosenstein Breaking change  Rename from craftr-dsl to builddsl@NiklasRosenstein"},{"location":"changelog/#090-2022-04-21","title":"0.9.0 (2022-04-21)","text":"TypeDescriptionPRIssuesAuthor Feature  Expose `NameRewriter` functionality as a a public API under the name `builddsl.ast_utils.DynamicLookupRewriter`@NiklasRosenstein"},{"location":"changelog/#085-2022-04-19","title":"0.8.5 (2022-04-19)","text":"TypeDescriptionPRIssuesAuthor Improvement  Add `Context.chain_with()`@NiklasRosenstein Improvement  Add `Closure(target_context)` parameter@NiklasRosenstein"},{"location":"changelog/#084-2022-04-19","title":"0.8.4 (2022-04-19)","text":"TypeDescriptionPRIssuesAuthor Fix  Support previously missing `!=` comparator@NiklasRosenstein"},{"location":"changelog/#083-2022-04-19","title":"0.8.3 (2022-04-19)","text":"TypeDescriptionPRIssuesAuthor Fix  Fix `import module` not treating `module` as a local variable definition8@NiklasRosenstein"},{"location":"changelog/#082-2022-04-18","title":"0.8.2 (2022-04-18)","text":"TypeDescriptionPRIssuesAuthor Improvement  Disable debug line that is really just useful for debugging in the project directly;@NiklasRosenstein"},{"location":"changelog/#081-2022-04-14","title":"0.8.1 (2022-04-14)","text":"TypeDescriptionPRIssuesAuthor Improvement  Make `astor` dependency an extra called \"astor\", it is required only for `transpile_to_source()`@NiklasRosenstein"},{"location":"changelog/#080-2022-04-13","title":"0.8.0 (2022-04-13)","text":"TypeDescriptionPRIssuesAuthor Feature  support Python 3.7@NiklasRosenstein"},{"location":"changelog/#077-2022-02-27","title":"0.7.7 (2022-02-27)","text":"TypeDescriptionPRIssuesAuthor Improvement  support Python 3.8+ (before was 3.10)@NiklasRosenstein"},{"location":"changelog/#076-2022-02-27","title":"0.7.6 (2022-02-27)","text":"TypeDescriptionPRIssuesAuthor Fix  support walrus operator (`:=`)5@NiklasRosenstein"},{"location":"changelog/#075-2022-02-27","title":"0.7.5 (2022-02-27)","text":"TypeDescriptionPRIssuesAuthor Fix  support more assignment operators like `+=`, `-=`, etc. as well as `and` and `or` binary operators7@NiklasRosenstein"},{"location":"introduction/","title":"Introduction","text":"<p>BuildDSL is a Python superset language inspired by Gradle.</p> <p>It introduces additional syntactic constructs into the language, such as paren-less function calls, colon keyword arguments, paren-less line-spanning statements without newline escaping and multi-line lambdas (called \"closures\").</p> <p>Optionally, a feature can be enabled to allow for dynamic variable name resolution which allows for a concise syntax that does not require prefixing members of the closure target with <code>self</code>.</p>"},{"location":"introduction/#example","title":"Example","text":"<p>This might be a bit of a convoluted way to print \"Hello, World\", but it shows well how closures in BuildDSL work:</p> <pre><code># hello.build\nworld = { self('World!') }\nworld {\n  print('Hello,', self)\n}\n</code></pre> <p>This transpiles to</p> StandardDynamic name resolution <pre><code># $ python -m builddsl hello.build -E | grep -v -e '^$'\ndef _closure_1(self, *arguments, **kwarguments):\n    self('World!')\nworld = _closure_1\ndef _closure_2(self, *arguments, **kwarguments):\n    print('Hello,', self)\nworld(_closure_2)\n</code></pre> <pre><code># $ python -m builddsl hello.build -E -C | grep -v -e '^$'\n@__closure__.subclosure\ndef _closure_1(__closure__, self, *arguments, **kwarguments):\n    self('World!')\n__closure__['world'] = _closure_1\n@__closure__.subclosure\ndef _closure_2(__closure__, self, *arguments, **kwarguments):\n    __closure__['print']('Hello,', self)\n__closure__['world'](_closure_2)\n</code></pre> <p>And evaluates to</p> <pre><code># $ python -m builddsl hello.build\nHello, World!\n</code></pre> <p>Note</p> <p>BuildDSL is not usually designed to be used for standalone scripts, but usually as a configuration language for other systems. It is therefore uncommon to run any production code through <code>python -m builddsl</code>. Code transpiled using dynamic name resolution requires a root closure to be supplied as well, which is not possible via the command-line.</p> <p>However, the command-line interface is very useful to run quick tests and to inspect what the transpiled version of the code looks like.</p>"},{"location":"api/cli/","title":"Command-line","text":"<pre><code>    $ python -m builddsl -h  # exited with return code 1\n    /opt/hostedtoolcache/Python/3.10.10/x64/bin/python: No module named builddsl\n</code></pre>"},{"location":"api/docs/","title":"Documentation","text":"<p>@pydoc builddsl.execute</p> <p>@pydoc builddsl.Grammar</p> <p>@pydoc builddsl.SyntaxError</p> <p>@pydoc builddsl.ChainContext</p> <p>@pydoc builddsl.Closure</p> <p>@pydoc builddsl.Context</p> <p>@pydoc builddsl.MapContext</p> <p>@pydoc builddsl.ObjectContext</p> <p>@pydoc builddsl.TranspileOptions</p> <p>@pydoc builddsl.transpile_to_ast</p> <p>@pydoc builddsl.transpile_to_source</p>"},{"location":"api/usage-example/","title":"Usage example","text":"<p>This example is from the Novella project. It uses the <code>builddsl.Closure</code> class to execute a file that contains BuildDSL code using a <code>NovellaContext</code> object as the root closure target. This allows members of the target object to be invoked at the top-level of the script directly without explicitly prefixing the member names with <code>self</code> or any of the sort. </p> <pre><code>class Novella:\n\"\"\" This class is the main entrypoint for starting and controlling a Novella build. \"\"\"\n\n  BUILD_FILE = Path('build.novella')\n\n  def __init__(self, project_directory: Path) -&gt; None:\n    self.project_directory = project_directory\n\n  def execute_file(self, file: Path | None = None) -&gt; NovellaContext:\n\"\"\" Execute a file, allowing it to populate the Novella pipeline. \"\"\"\n\n    from builddsl import Closure\n    context = NovellaContext(self)\n    file = file or self.BUILD_FILE\n    Closure(None, None, context).run_code(file.read_text(), str(file))\n    return context\n\nclass NovellaContext:\n\n  def do(\n    self,\n    action_type_name: str,\n    closure: t.Callable | None = None,\n    name: str | None = None,\n  ) -&gt; None:\n\n  # ...\n</code></pre> <p>Example script</p> <pre><code>do \"copy-files\" {\n  content = [ \"content\", \"mkdocs.yml\" ]\n}\n</code></pre>"},{"location":"syntax/closures/","title":"Closures","text":"<p>Closures are formed with the following syntax: <code>[ arg -&gt; | (arg1, arg2, ...) -&gt; ] { body }</code>. A closure without an argument list automatically has the signature <code>(self, *argnames, **kwargnames)</code>.</p>"},{"location":"syntax/closures/#example-1","title":"Example 1","text":"BuildDSLPython <pre><code>filter({ self % 2 }, range(5))\n</code></pre> <pre><code>def _closure_1(self, *argnames, **kwargnames):\n    self % 2\nfilter(_closure_1, range(5))\n</code></pre> <p>No return statement</p> <p>Note how a closure surrounded by braces does not have an implicit return statement.</p>"},{"location":"syntax/closures/#example-2","title":"Example 2","text":"BuildDSLPython <pre><code>filter(x -&gt; x % 2, range(5))\n</code></pre> <pre><code>def _closure_1(x):\n    return x % 2\nfilter(_closure_1, range(5))\n</code></pre>"},{"location":"syntax/closures/#example-3","title":"Example 3","text":"BuildDSLPython <pre><code>reduce((a, b) -&gt; {\n  a.append(b * 2)\n  return a\n}, [1, 2, 3], [])\n</code></pre> <pre><code>def _closure_1(a, b):\n    a.append(b * 2)\n    return a\nreduce(_closure_1, [1, 2, 3], [])\n</code></pre>"},{"location":"syntax/function-args/","title":"Unseparated arguments &amp; colon keyword arguments","text":"<p>The BuildDSL allows passing arguments to function calls without separation by commas. Keyword arguments may be specified using colons (<code>:</code>) instead of equal signs (<code>=</code>).</p>"},{"location":"syntax/function-args/#example-1","title":"Example 1","text":"BuildDSLPython <pre><code>print 'Hello, World!' 42 * 1 + 10 file: sys.stdout\n</code></pre> <pre><code>print('Hello, World!', 42 * 1 + 10, file=sys.stdout)\n</code></pre>"},{"location":"syntax/function-args/#example-2","title":"Example 2","text":"BuildDSLPython <pre><code>task \"hello_world\" do: {\n  print \"Hello, World!\"\n}\n</code></pre> <pre><code>def _closure_1(self, *arguments, **kwarguments):\n    print('Hello, World!')\ntask('hello_world', do=_closure_1)\n</code></pre>"},{"location":"syntax/function-args/#example-3","title":"Example 3","text":"BuildDSLPython <pre><code>list(map { print('Hello,', self) } ['John', 'World'])\n</code></pre> <pre><code>def _closure_1(self, *arguments, **kwarguments):\n    print('Hello,', self)\nlist(map, _closure_1['John', 'World'])\n</code></pre> <p>Danger</p> <p>Note how this actually passes all arguments to <code>list()</code> and it tries to index an element on the closure. The outer-most statement has the priority to receive the arguments, and subscripting takes precedence over the subscript being treated as a separate argument.</p> BuildDSLPython <pre><code>list(map({ print('Hello,', self) }, ['John', 'World']))\n</code></pre> <pre><code>def _closure_1(self, *arguments, **kwarguments):\n    print('Hello,', self)\n\nlist(map(_closure_1, ['John', 'World']))\n</code></pre>"},{"location":"syntax/function-calls/","title":"Function calls without parentheses","text":"<p>Such function calls are only supported at the statement level. A function can be called without parentheses by simply omitting them. Variadic and keyword arguments are supported as expected. Applying a closure on an object is basically the same as calling that object with the function, and arguments following the closure are still supported.</p>"},{"location":"syntax/function-calls/#example-1","title":"Example 1","text":"BuildDSLPython <pre><code>print 'Hello, World!', file=sys.stderr\n</code></pre> <pre><code>print('Hello, World!', file=sys.stderr)\n</code></pre>"},{"location":"syntax/function-calls/#example-2","title":"Example 2","text":"BuildDSLPython <pre><code>map {\n  print('Hello,', self)\n}, ['John', 'World']\n</code></pre> <pre><code>def _closure_1(self, *arguments, **kwarguments):\n    print('Hello,', self)\nmap(_closure_1, ['John', 'World'])\n</code></pre>"},{"location":"syntax/limitations/","title":"Limitations","text":"<p>BuildDSL is intended to behave as a complete syntactic superset of standard Python. However there are currently some limitations, namely:</p> <ul> <li>Literal sets cannot be expressed due to the grammar conflict with parameter-less closures</li> <li>Type annotations are not currently supported</li> <li>The walrus operator is not currently supported</li> <li>Function calls without parenthesis do not support passing <code>*args</code> as the first argument as that is   interpreted as a multiplication expression.</li> </ul>"},{"location":"syntax/name-resolution/","title":"Dynamic name resolution (non-default)","text":"<p>For some purposes and applications, dynamic name resolution may be desirable, for example when writing <code>self</code> in front of every name to access a property of the closure target object is too cumbersome. For this, the BuildDSL transpiler can generate code that looks up, sets and deletes keys using subscript syntax on a particular variable name.</p> <p>Using the <code>builddsl.runtime</code> package, you can configure the transpiler and runtime to use dynamic name resolution. Example usage:</p> <pre><code>from builddsl.transpiler import transpile_to_ast\nfrom builddsl.runtime import Closure\n\nclass Project:\n  def task(self, name: str, *, do: callable): ...\n\ncode = ...\nfilename = ...\n\n# Long form:\nmodule = transpile_to_ast(code, filename, Closure.get_options())\ncode = compile(module, filename, 'exec')\nscope = {'__closure__': Closure(None, None, Project())}\nexec(code, scope)\n\n# Shorthand form:\nClosure(None, None, Project()).run_code(code, filename)\n</code></pre> <p>The <code>Closure.get_options()</code> function returns <code>TranspileOptions</code> that instruct the transpiler to convert name lookups into subscripts on the <code>__closure__</code> variable, add a <code>@__closure__.subclosure</code> decoration before every closure function definition and to add a <code>__closure__,</code> argument to their arglist. The <code>Closure</code> object passed into the <code>scope</code> on execution deals with the rest.</p> BuildDSLPython <pre><code>task \"foobar\" do: {\n  return n_times\n}\n\ntask \"belzebub\" do: {\n  def n_times = 1\n  return n_times\n}\n\ntask \"cheeky\" do: {\n  def n_times = 1\n  return (() -&gt; n_times )()\n}\n</code></pre> <pre><code>@__closure__.subclosure\ndef _closure_1(__closure__, self, *arguments, **kwarguments):\n    return __closure__['n_times']\n__closure__['task']('foobar', do=_closure_1)\n\n@__closure__.subclosure\ndef _closure_2(__closure__, self, *arguments, **kwarguments):\n    n_times = 1\n    return n_times\n__closure__['task']('belzebub', do=_closure_2)\n\n@__closure__.subclosure\ndef _closure_3(__closure__, self, *arguments, **kwarguments):\n    n_times = 1\n    @__closure__.subclosure\n    def _closure_3_closure_3(__closure__):\n        return n_times\n    return _closure_3_closure_3()\n__closure__['task']('cheeky', do=_closure_3)\n</code></pre>"}]}